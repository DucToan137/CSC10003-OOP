#include "bits/stdc++.h"
using namespace std;

namespace Utils {
    class String {
    public:
        static vector<string> split(string haystack, string needle) {
            vector<string> result;
            int startPos = 0;
            size_t foundPos = haystack.find(needle, startPos);

            while (foundPos != string::npos) {
                int count = foundPos - startPos;
                string token = haystack.substr(startPos, count);
                result.push_back(token);

                startPos = foundPos + needle.length();
                foundPos = haystack.find(needle, startPos);
            }

            // The remaining
            string token = haystack.substr(startPos, haystack.length() - startPos);
            result.push_back(token);

            return result;
        }
    };
}

class Object {
public:
	virtual std::string toString() = 0;
};



class IParsable : public Object{
public:
	virtual Object* parse(std::string) = 0;
	std::string toString() override{
		return "IParsable";
	};
	virtual std::string parsedObjectName() = 0;
};

class Employee : public Object{
public:
	virtual int salary() = 0;
	std::string toString() override;
};

class ParserFactory : public Object {
private:
	std::map<std::string, IParsable*> _container;

public:
	void registerWith(IParsable* parser);
	IParsable* create(std::string type);
	std::string toString();
};


class IValueConverter : public Object {
public:
	virtual std::string convert(Object* Obj) = 0;
	virtual std::string toString() override {
		return "IValueConverter";
	};
};

class Integer : public Object {
private:
	int _value;
public:
	Integer();
	Integer(int);
	int value();
	std::string toString();
};

class NumberFormatInfo : public Object {
private:
	std::string _currencyDecimalSeparator = ".";
	std::string _currencySymbol = "d";

	//https://stackoverflow.com/questions/17459450/how-to-determine-currency-symbol-position-for-a-culture
	int _currencyPositive = 3;				// 0		1		2		3
	std::string _currencyPositiveFormat = "n $"; // "$n"		"n$"	"$ n"	"n $"
public:
	std::string currencyDecimalSeparator();
	std::string currencySymbol();
	int currencyPositive();
	std::string currencyPositiveFormat();
public:
	std::string toString() override;
};

class DailyEmployee : public Employee {
private:
	int _dayCount;
	int _paymentPerDay;
public:
	DailyEmployee();
	DailyEmployee(int dayCount, int paymentPerDay);
	std::string toString() override;
	int salary() override;
};

class Manager : public Employee {
private:
	int _employeeCount;
	int _paymentPerEmployee;
	int _baseSalary;
public:
	Manager();
	Manager(int employeeCount, int paymentPerEmployee, int baseSalary);
	std::string toString() override;
	int salary() override;
};

class ProductEmployee : public Employee {
private:
	int _productCount;
	int _paymentPerProduct;
public:
	ProductEmployee();
	ProductEmployee(int productCount, int paymentPerProduct);
	std::string toString() override;
	int salary() override;
};

class DailyEmployeeParser : public IParsable {
public:
	Object* parse(std::string data) override;
	std::string toString() override;
	std::string parsedObjectName() override;
};

class ManagerParser : public IParsable {
public:
	Object* parse(std::string data) override;
	std::string toString() override;
	std::string parsedObjectName() override;
};

class ProductEmployeeParser : public IParsable {
public:
	Object* parse(std::string data) override;
	std::string toString() override;
	std::string parsedObjectName() override;
};

class IntegerToCurrencyConverter : public IValueConverter {
public:
	std::string convert(Object* Obj) override;
	std::string toString() override;
};

std::string Employee::toString() {
	return "Employee";
}

void ParserFactory::registerWith(IParsable* parser) {
	_container.insert(
		{ parser->parsedObjectName(), parser }
	);
}

IParsable* ParserFactory::create(std::string type) {
    return _container[type];;
}

std::string ParserFactory::toString() {
    return "Move to ParseFactory";
}

std::string NumberFormatInfo::currencyDecimalSeparator () {
	return _currencyDecimalSeparator;
}

std::string NumberFormatInfo::currencySymbol () {
	return _currencySymbol;
}

int NumberFormatInfo::currencyPositive() {
	return _currencyPositive;
}

std::string NumberFormatInfo::currencyPositiveFormat () {
	return _currencyPositiveFormat;
}

std::string NumberFormatInfo::toString () {
	return "NumberFormatInfo";
}


Integer::Integer() {
	_value = 0;
}

Integer::Integer(int value) {
	_value = value;
}

std::string Integer::toString() {
	return "Integer";
}

int Integer::value() {
	return _value;
}

DailyEmployee::DailyEmployee() {
	_dayCount = 0;
	_paymentPerDay = 0;
}
DailyEmployee::DailyEmployee(int dayCount, int paymentPerDay) {
	_dayCount = dayCount;
	_paymentPerDay = paymentPerDay;
}

std::string DailyEmployee::toString() {
	return "Daily employee";
}
int DailyEmployee::salary() {
	return _paymentPerDay * _dayCount;
}

Object* DailyEmployeeParser::parse(string data) {
	//"DailyEmployee dayCount=20, paymentPerPay=1000000"
	vector<string> token = Utils::String::split(data, ", ");
	int dayCount = stoi((Utils::String::split(token[0], "="))[1]);
	int paymentPerPay = stoi((Utils::String::split(token[1], "="))[1]);
	return new DailyEmployee(dayCount, paymentPerPay);
}
string DailyEmployeeParser::toString() {
	return "convert to EmployeeDaily";
}

string DailyEmployeeParser::parsedObjectName() {
	return "DailyEmployee";
}

string IntegerToCurrencyConverter::convert(Object* object) {
	auto number = dynamic_cast<Integer*>(object);
	int value = number->value();

	stringstream builder;
	NumberFormatInfo info;
	int count = 0;

	while (value != 0) {
		int lastDigit = value % 10;
		builder << lastDigit;

		count++;
		value /= 10;
		if (count == 3 && value != 0) {
			builder << info.currencyDecimalSeparator();
			count = 0;
		}
	}

	string numberSeparated = builder.str(); // "000.000.1"
	reverse(numberSeparated.begin(), numberSeparated.end());

	string format = info.currencyPositiveFormat(); //"n $" ==> "1.000.000 d"
	string symbol = info.currencySymbol(); // "d"
	string result = regex_replace(format, regex("n"), numberSeparated);
	result = regex_replace(result, regex("\\$"), symbol);

	return result;
}

std::string IntegerToCurrencyConverter::toString() {
	return "IntegerToCurrencyConverter";
}

Manager::Manager() {
	_employeeCount = 0;
	_paymentPerEmployee = 0;
	_baseSalary = 0;
}
Manager::Manager(int employeeCount, int paymentPerEmployee, int baseSalary) {
	_employeeCount = employeeCount;
	_paymentPerEmployee = paymentPerEmployee;
	_baseSalary = baseSalary;
}
	
std::string Manager::toString() {
	return "Manager";
}
int Manager::salary() {
	return _employeeCount * _paymentPerEmployee + _baseSalary;
}

Object* ManagerParser::parse(string data) {
	//"Manager employeeCount=49, paymentPerEmployee=500000, baseSalary=6000000"
	vector<string> token = Utils::String::split(data, ", ");
	int employeeCount = stoi((Utils::String::split(token[0], "="))[1]);
	int paymentPerEmployee = stoi((Utils::String::split(token[1], "="))[1]);
	int baseSalary = stoi((Utils::String::split(token[2], "="))[1]);
	return new Manager(employeeCount, paymentPerEmployee, baseSalary);
}

string ManagerParser::toString() {
	return "convert to Manager";
}

string ManagerParser::parsedObjectName() {
	return "Manager";
}

ProductEmployee::ProductEmployee() {
	_productCount = 0;
	_paymentPerProduct = 0;
}
ProductEmployee::ProductEmployee(int productCount, int paymentPerProduct) {
	_productCount = productCount;
	_paymentPerProduct = paymentPerProduct;
}

std::string ProductEmployee::toString() {
	return "Product employee";
}

int ProductEmployee::salary() {
	return _paymentPerProduct * _productCount;
}

Object* ProductEmployeeParser::parse(string data) {
	//"ProductEmployee productCount=900, paymentPerProduct=18000"
	vector<string> token = Utils::String::split(data, ", ");
	int productCount = stoi((Utils::String::split(token[0], "="))[1]);
	int paymentPerProduct = stoi((Utils::String::split(token[1], "="))[1]);
	return new ProductEmployee(productCount, paymentPerProduct);
}
string ProductEmployeeParser::toString() {
	return "convert to ProductEmployee";
}

string ProductEmployeeParser::parsedObjectName() {
	return "ProductEmployee";
}



#include "main.h"